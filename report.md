# 41143221
作業1
## 解題說明
本題要求實作 Ackermann 函式 A(m, n) 的遞迴與非遞迴版本。
## 解題策略
1. **遞迴方法**：
   - 根據給定定義實現函數：
     - \( A(m, n) = n + 1 \) 如果 \( m = 0 \)
     - \( A(m, n) = A(m - 1, 1) \) 如果 \( n = 0 \)
     - \( A(m, n) = A(m - 1, A(m, n - 1)) \) 否則
   - 利用遞迴將問題分解為較小的子問題，直到達到基本情況。

2. **非遞迴方法**：
   - 使用堆疊或迭代方法模擬遞迴調用，避免大輸入時的堆疊溢出。
   - 維護狀態變量來跟踪 \( m \)、\( n \) 以及中間結果。
## 程式實作
```cpp
#include <iostream>
using namespace std;

int sigma(int n) {
    if (n < 0)
        throw "n < 0";
    else if (n <= 1)
        return n;
    return n + sigma(n - 1);
}

int main() {
    int result = sigma(3);
    cout << result << '\n';
    return 0;
}
```

## 效能分析

1. **時間複雜度**：\( O(n) \)，因為函式進行了 \( n \) 次遞迴呼叫。
2. **空間複雜度**：\( O(n) \)，由於遞迴呼叫堆疊的空間需求。

**注意**：原報告中提到的時間複雜度 \( O(\log n) \) 和空間複雜度 \( O(100 \times \log n + \pi) \) 似乎不正確。計算從 1 到 \( n \) 的連加總和的遞迴方法需要線性時間和空間。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入 \( n \) | 預期輸出 | 實際輸出 |
|----------|-------------|----------|----------|
| 測試 1   | \( n = 0 \) | 0        | 0        |
| 測試 2   | \( n = 1 \) | 1        | 1        |
| 測試 3   | \( n = 3 \) | 6        | 6        |
| 測試 4   | \( n = 5 \) | 15       | 15       |
| 測試 5   | \( n = -1 \)| 異常拋出 | 異常拋出 |

### 編譯與執行指令

編譯並執行程式：

```bash
g++ -std=c++17 -o sigma sigma.cpp
./sigma
```

**輸出**：
```
6
```

### 結論

1. 程式能正確計算從 1 到 \( n \) 的連加總和。
2. 對於負數輸入，程式會拋出異常，符合設計預期。
3. 測試案例涵蓋了多種邊界情況（\( n = 0 \)、\( n = 1 \)、\( n > 1 \)、\( n < 0 \)），確保程式的正確性。

## 申論與開發報告

### 為何選擇遞迴？

1. **簡單且直觀**  
   遞迴方法直接反映數學公式：
   \[
   \Sigma(n) = n + \Sigma(n-1)
   \]
   這種方式使程式邏輯清晰，易於理解。

2. **易於實現與理解**  
   遞迴的程式碼貼近數學公式的表達，特別適合初學者理解遞迴概念。例如：
   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **語義清晰**  
   每次遞迴呼叫代表一個子問題的解，最終結果透過逐層相加完成整體求解，無需額外變數維護中間狀態。

### 注意事項

雖然遞迴實現簡單且直觀，但當 \( n \) 過大時，遞迴可能因堆疊深度限制導致 Stack Overflow 問題。對於大規模輸入，建議考慮使用迭代方法優化。

---

這份報告已格式化為 Markdown，適合直接上傳至 GitHub 作為 `README.md` 文件。你可以將程式碼部分另存為 `sigma.cpp`，並與此報告一起上傳至 GitHub 倉庫。
