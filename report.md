41143263
作業一
解題說明
Problem 1: Ackermann 函數
本題要求實現 Ackermann 函數 $   A(m, n)   $，其定義為：

$   A(m, n) = n + 1   $，若 $   m = 0   $
$   A(m, n) = A(m - 1, 1)   $，若 $   n = 0   $
$   A(m, n) = A(m - 1, A(m, n - 1))   $，其他情況

該函數因增長極快而被研究，需分別撰寫遞迴與非遞迴實現。
Problem 2: Power Set
本題要求計算集合 $   S   $ 的所有可能子集（Power Set）。例如，若 $   S = \{a, b, c\}   $，則 Power Set 為 $   \{\{\}, \{a\}, \{b\}, \{c\}, \{a, b\}, \{a, c\}, \{b, c\}, \{a, b, c\}\}   $。需使用遞迴函數實現。
解題策略
Problem 1

遞迴策略：直接根據定義實現遞迴函數，處理三種情況（$   m = 0   $、$   n = 0   $ 及其他）。
非遞迴策略：使用迴圈模擬遞迴過程，需紀錄中間狀態以避免無限遞迴。

Problem 2

遞迴策略：通過遞迴處理集合的每個元素，選擇包含或不包含該元素來生成子集。


# 41143221
作業1
## 解題說明
本題要求實作 Ackermann 函式 A(m, n) 的遞迴與非遞迴版本。
### 解題策略
1. **遞迴方法**：
   - 根據給定定義實現函數：
     - \( A(m, n) = n + 1 \) 如果 \( m = 0 \)
     - \( A(m, n) = A(m - 1, 1) \) 如果 \( n = 0 \)
     - \( A(m, n) = A(m - 1, A(m, n - 1)) \) 否則
   - 利用遞迴將問題分解為較小的子問題，直到達到基本情況。

2. **非遞迴方法**：
   - 使用堆疊或迭代方法模擬遞迴調用，避免大輸入時的堆疊溢出。
   - 維護狀態變量來跟踪 \( m \)、\( n \) 以及中間結果。
## 程式實作
```cpp
#include <iostream>
using namespace std;

int sigma(int n) {
    if (n < 0)
        throw "n < 0";
    else if (n <= 1)
        return n;
    return n + sigma(n - 1);
}

int main() {
    int result = sigma(3);
    cout << result << '\n';
    return 0;
}
```

## 效能分析

1. **時間複雜度**：\( O(n) \)，因為函式進行了 \( n \) 次遞迴呼叫。
2. **空間複雜度**：\( O(n) \)，由於遞迴呼叫堆疊的空間需求。


## 測試與驗證

### 測試案例

| 測試案例 | 輸入 \( n \) | 預期輸出 | 實際輸出 |
|----------|-------------|----------|----------|
| 測試 1   | \( n = 0 \) | 0        | 0        |
| 測試 2   | \( n = 1 \) | 1        | 1        |
| 測試 3   | \( n = 3 \) | 6        | 6        |
| 測試 4   | \( n = 5 \) | 15       | 15       |
| 測試 5   | \( n = -1 \)| 異常拋出 | 異常拋出 |

### 編譯與執行指令

編譯並執行程式：

```bash
g++ -std=c++17 -o sigma sigma.cpp
./sigma
```

**輸出**：
```
6
```

### 結論

1. 程式能正確計算從 1 到 \( n \) 的連加總和。
2. 對於負數輸入，程式會拋出異常，符合設計預期。
3. 測試案例涵蓋了多種邊界情況（\( n = 0 \)、\( n = 1 \)、\( n > 1 \)、\( n < 0 \)），確保程式的正確性。

## 申論與開發報告

### 為何選擇遞迴？

1. **簡單且直觀**  
   遞迴方法直接反映數學公式：
   \[
   \Sigma(n) = n + \Sigma(n-1)
   \]
   這種方式使程式邏輯清晰，易於理解。

2. **易於實現與理解**  
   遞迴的程式碼貼近數學公式的表達，特別適合初學者理解遞迴概念。例如：
   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **語義清晰**  
   每次遞迴呼叫代表一個子問題的解，最終結果透過逐層相加完成整體求解，無需額外變數維護中間狀態。

### 注意事項

雖然遞迴實現簡單且直觀，但當 \( n \) 過大時，遞迴可能因堆疊深度限制導致 Stack Overflow 問題。對於大規模輸入，建議考慮使用迭代方法優化。

