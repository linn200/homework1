# 作業一

## Problem 1: Ackermann 函數

### 解題說明

Ackermann 函數 $A(m, n)$ 是一個遞迴定義的函數，增長極快，用於研究遞迴和計算複雜性。解題分為兩步：

#### 遞迴實現
直接根據數學定義實現：
$$
A(m, n) =
\begin{cases} 
n + 1 & \text{if } m = 0 \\
A(m-1, 1) & \text{if } m > 0 \text{ and } n = 0 \\
A(m-1, A(m, n-1)) & \text{if } m > 0 \text{ and } n > 0 
\end{cases}
$$

#### 非遞迴實現
使用堆疊模擬遞迴過程，儲存 $(m, n)$ 狀態，逐步計算每個遞迴步驟。

#### 舉例說明
計算 $A(1, 2)$：
- $A(1, 2) = A(0, A(1, 1))$
- $A(1, 1) = A(0, A(1, 0))$
- $A(1, 0) = A(0, 1) = 2$
- $A(1, 1) = A(0, 2) = 3$
- $A(1, 2) = A(0, 3) = 4$

### 程式實作
見 `ackermann.cpp`。

### 效能分析
1. **時間複雜度**：Ackermann 函數的時間複雜度無法用簡單的指數形式表示，因其增長速度極快，屬於非原始遞迴函數。對於給定的 $m$ 和 $n$，計算次數隨著 $m$ 增加呈現超指數增長。
2. **空間複雜度**：
   - 遞迴實現：遞迴深度取決於 $m$ 和 $n$，最壞情況下可能遠超 $O(m)$ 或 $O(n)$。
   - 非遞迴實現：使用堆疊儲存中間狀態，空間複雜度與遞迴深度相關，但可避免系統堆疊溢出。

### 測試與驗證
#### 測試案例
- $A(0, 0) = 1$
- $A(1, 1) = 3$
- $A(2, 1) = 5$

#### 驗證
對小值 $m, n \leq 2$ 測試，遞迴與非遞迴結果相同，與手動計算一致，證明正確性。

#### 編譯與執行指令
```shell
$ g++ -std=c++17 -o ackermann ackermann.cpp
$ ./ackermann
Enter m and n: 1 2
A(1, 2) (Recursive) = 4
A(1, 2) (Non-recursive) = 4
```

### 申論及開發報告
#### 選擇遞迴與非遞迴的原因
1. **遞迴實現的直觀性**  
   Ackermann 函數的定義本質上是遞迴的，直接按照數學定義實現程式碼邏輯清晰，易於理解，適合教學和驗證。
2. **非遞迴實現的必要性**  
   Ackermann 函數增長極快，遞迴深度可能導致堆疊溢出。非遞迴實現使用堆疊模擬遞迴過程，將遞迴轉化為迭代，避免系統堆疊限制。
3. **實現的簡潔性與正確性**  
   遞迴版本程式碼簡潔，易於驗證數學正確性；非遞迴版本通過顯式堆疊管理，確保計算過程可控。兩者結合展示了遞迴與迭代的不同設計思路。

## Problem 2: 冪集

### 解題說明
冪集包含集合 $S$ 的所有子集，數量為 $2^n$。遞迴方法通過選擇或不選擇當前元素，生成所有組合。

#### 舉例說明
對於 $S = \{a, b\}$，遞迴生成冪集的過程如下：
- 從空集開始：$\{\}$
- 考慮元素 $a$：
  - 不選 $a$：保持 $\{\}$
  - 選 $a$：生成 $\{a\}$
- 考慮元素 $b$：
  - 基於 $\{\}$：不選 $b$（保持 $\{\}$），選 $b$（生成 $\{b\}$）
  - 基於 $\{a\}$：不選 $b$（保持 $\{a\}$），選 $b$（生成 $\{a, b\}$）
- 最終結果：$\{\{\}, \{a\}, \{b\}, \{a, b\}\}$

### 程式實作
見 `powerset.cpp`。

### 效能分析
1. **時間複雜度**：$O(2^n)$，因為每個元素有選或不選兩種選擇，生成 $2^n$ 個子集。
2. **空間複雜度**：$O(2^n)$ 用於儲存所有子集，遞迴深度為 $O(n)$，額外需要 $O(n)$ 的空間儲存當前子集的字串。

### 測試與驗證
#### 測試案例
- $S = "ab"$: $\{\{\}, \{a\}, \{b\}, \{a, b\}\}$
- $S = "abc"$: $\{\{\}, \{a\}, \{b\}, \{c\}, \{a, b\}, \{a, c\}, \{b, c\}, \{a, b, c\}\}$

#### 驗證
手動檢查子集數和內容，與數學定義一致，程式輸出按字典序排序，符合預期。

#### 編譯與執行指令
```shell
$ g++ -std=c++17 -o powerset powerset.cpp
$ ./powerset
Enter the set elements (e.g., 'abc'): ab
Powerset of {ab} = { {}, {a}, {b}, {a, b} }
```